package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"sync"

	"github.com/pkg/sftp"
	"golang.org/x/crypto/ssh"
)
/Library/Java/JavaVirtualMachines/jdk-20.jdk/Contents/Home

JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-20.jdk/Contents/Home
PATH=$JAVA_HOME/bin:$PATH:.
CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.
export JAVA_HOME
export PATH
export CLASSPATH
————————————————
版权声明：本文为CSDN博主「rambleclouds」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_61536532/article/details/126791735
const (
	MaxConcurrentDownloads = 10
	NumFilesToDownload     = 1000
)

type DownloadJob struct {
	Filename string
}

func main() {
	// 建立SSH连接
	。。。。。
	defer sftpClient.Close()

	// 创建等待组和工作通道
	var wg sync.WaitGroup
	jobChan := make(chan DownloadJob)

	// 启动工作池
	for i := 0; i < MaxConcurrentDownloads; i++ {
		go worker(jobChan, &wg, sftpClient)
	}

	// 添加下载任务到工作通道
	for i := 0; i < NumFilesToDownload; i++ {
		filename := fmt.Sprintf("file%d.txt", i+1)
		job := DownloadJob{Filename: filename}
		jobChan <- job
		wg.Add(1)
	}

	// 等待所有下载完成
	wg.Wait()
	close(jobChan)
	fmt.Println("All downloads completed.")
}

// 工作池的工作函数
func worker(jobChan <-chan DownloadJob, wg *sync.WaitGroup, sftpClient *sftp.Client) {
	for job := range jobChan {
		// 建立每个goroutine的独立SFTP会话
		sftpSession, err := sftpClient.NewSession()
		if err != nil {
			log.Printf("Failed to create SFTP session: %v", err)
			wg.Done()
			continue
		}

		// 执行文件下载
		err = downloadFile(sftpSession, job.Filename)
		if err != nil {
			log.Printf("Failed to download file %s: %v", job.Filename, err)
		}

		sftpSession.Close()
		wg.Done()
	}
}

// 下载文件
func downloadFile(session *sftp.Client, filename string) error {
	srcFile, err := session.Open(filename)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = io.Copy(dstFile, srcFile)
	if err != nil {
		return err
	}

	return nil
}
